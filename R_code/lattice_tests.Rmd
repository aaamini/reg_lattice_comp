---
title: "lattice_tests"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading or creating the data

```{r message=FALSE}
source('load_lattice_data.R')
```

Plot $B$
```{r  fig.height=3, fig.width=3}
image(Bet, sub="", xlab="", ylab="")
```


Plot of the inverse covariance matrix 
```{r, fig.height=3, fig.width=3}
image(Gamma, sub="", xlab="", ylab="")

```

and the covariance matrix
```{r, fig.height=3, fig.width=3}
image(Sig, sub="", xlab="", ylab="")
```

\newpage
and the PCG
```{r, fig.height=4.5, fig.width=4.5}
plot(pcg)
```

and the original DAG
```{r, fig.height=4.5, fig.width=4.5}
plot(dag)
```

\newpage
# SEM coefficients and single lattice computations
An example of getting SEM coefficients $\beta_j(S)$
```{r}
j <- 2
S <- c(3,4,7,8,10)
print(getParentCoefs2(j, S, Sig, threshold=T)$coefs,  col.names=T)
```

Computing an example lattice:
```{r}
j <- 2
S <- all_nodes[-j]
lat <- computeLattice(j, c(3,4,10), Sig, all_nodes, should_sort=F)
lat
```
The two sets shown are the minimum ($m$) and the maximum ($M$) of the lattice.

Checking whether a set belongs to a lattice:
```{r}
isInLattice(c(6,3,8,4,10),lat)
```

Another example ($j$ is `r j`)
```{r}
print(computeLattice(j, c(1,8,9,5,7), Sig, all_nodes), width=30)
```


\newpage
# Computing all subordinate lattices
Compute all the lattices subordinate to the lattice generated by `all_nodes[-j]` (i.e., have smaller minimums)
```{r}
lattices <- computeAllSubordinateLattices(j, Sig, all_nodes, print.width = 25, VERB=2)
```
and checking whether a set is in any of these:
```{r}
is_set_in_lattices(c(1,3,7,8,9),lattices)
```
Since this set is outside let us use it as root to generate more lattices:
```{r}
lattices <- computeAllSubordinateLattices(j, Sig, all_nodes, root_S = c(1,3,7,8,9), print.width = 25, VERB=2)
```

Let us change $j = 1$ and see what happens:
```{r}
j <- 1
lattices <- computeAllSubordinateLattices(j, Sig, all_nodes, print.width = 30, VERB=2)
```

\newpage
# Verify component decomposition

```{r}
#Randomly generate $j$ and $S \subset [d] \setminus j$
#S <- sample(1:d, sample(d-1,1))
#j <- sample(setdiff(all_nodes, S),1)
S <- c(2,3,4,5,7,9)
j <- 1
```
and verify the PCG connected component decomposition theorem (Theorem~?)
```{r}
out <- verifyComponentDecomp(j, S, pcg, Sig, all_nodes, print.width = 25, should_sort=T)
```

$j$ is shown in red, and $S$ in darker colors. The  `r length(out$G_comp)` component(s) after removing `j` are visible.

```{r}
out$verified
```

\newpage
## An example where this verification failed
```{r}
j <- 2
S <- c(3,4,6,7,10)
out <- verifyComponentDecomp(j, S, pcg, Sig, all_nodes, print.width = 25, should_sort=T)
```

What went wrong seems to be a failure of perfectness:
```{r}
A <- c(10)
j <- 2
R <-  c(1,3,5,7,9)
verifyL2MarkovPerfectness(j, A, R, pcg, Sig, VERB=1)
```

```{r}
# Another example
# S <- c(3,4,7)  
# S <- c(6,5,9)
# S <- c(8,9)
# j <- 1
# out <- verifyComponentDecomp(j, S, pcg, Sig, all_nodes, print.width = 25, should_sort=T)
```


\newpage
# Graph seperation calculations
Find all the nodes seperated from $A$ by $S$ (here $j = $ `r j`)
```{r}
  S <- c(3,4,7)
  A <- j
  out <- all_seperated_from_A_by_S(A, S, pcg, plot.subg=T)
  print(out$sep_set)

```
The distance matrix above is between $A$ and $[d]\setminus S$ in the graph obtained after removing $S$.

Another example
```{r}
  S <-  c(1,3,4)
  A <- j
  out <- all_seperated_from_A_by_S(A, S, pcg, plot.subg=T)
  out
```

\newpage
# Perfectness failure
```{r}
A <- c(3,10)
S <- c(2,7)
B <- 1
  
```

This verifies if $P_A P_S^\perp P_B = 0$:
```{r}
A_and_B_proj_seperated_by_S(A, S, B, Sig, threshold=T)
```


This verfies $A - S -B$ in the graph:
```{r}
A_and_B_graph_seperated_by_S(A, S, B, pcg, plot.subg=T)
```

This verifies Markov perfectness for triplet $(A,S,B)$ (basically whether the answer to the two questions above match):

```{r}
verifyL2MarkovPerfectness(A, S, B, pcg, Sig, VERB=1)
```


