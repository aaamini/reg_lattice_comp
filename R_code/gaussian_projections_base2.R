#library("graph")


THRESHOLD <- 1e-6 ### Global variable

all.subsets <- function(x){
    out <- list()
    for(j in 1:length(x)){
        j_sets <- combn(x, j, simplify = FALSE)
        out <- c(out, j_sets)
    }

    out <- c(list(NULL), out)
}

all.neighbourhoods <- function(nodes){
    out <- list()
    for(j in nodes){
        nodesj <- nodes[-j]
        setsj <- all.subsets(nodesj)
        out[[j]] <- setsj
    }

    out
}

check_if_diag <- function(m){
    off_diag <- sum(abs(m - diag(diag(m))))

    off_diag < THRESHOLD
}

check_if_dag <- function(m){
    m[m!=0] <- 1 # coerce to unweighted adjacency matrix to make graph package happy
    g <- as(m, "graphNEL")
    edgemode(g) <- "directed"
    ts <- suppressWarnings(RBGL::tsort(g))

    if(length(ts) == 0){
        FALSE
    } else{
        TRUE
    }
}

check_zero_col <- function(m){
    any(apply(m, 2, function(x) sum(abs(x))) < THRESHOLD)
}

count_nonzero <- function(m){
    length(which(abs(m) > THRESHOLD))
}

get_smallest_weight <- function(m){
    absm <- abs(m)
    threshm <- absm[absm > THRESHOLD]
    if(length(threshm) > 0){
        min(threshm)
    } else{
        NA
    }
}

count_all_sem <- function(pp){
    2^(pp*(pp-1))
}

tr <- function(m){
    stopifnot(is.matrix(m))
    sum(diag(m))
}

count_dags <- function(sem_list){
    sum(unlist(lapply(sem_list, function(x) x$acyclic)))
}

threshold_matrix <- function(m){
    m[abs(m) < THRESHOLD] <- 0

    m
}

getParentCoefs <- function(j, S, sigma, threshold=F){
  
    if(is.null(S)){
        coefs <- NULL
    } else{
        sigmaXY <- sigma[j, S]
        sigmaYY <- sigma[S, S]
        coefs <- sigmaXY %*% solve(sigmaYY)
    }
    if (threshold) coefs <- zapsmall(coefs)
    #coefs <- setNames(as.vector(coefs),S)
    ceofs <- as(coefs,"sparseMatrix")
    colnames(coefs) <- S
    list(coefs = coefs, parents = S, node = j)
}


getParentCoefs2 <- function(j, S, sigma, threshold=F){
  d <- dim(sigma)[1]
  if(is.null(S)){
    coefs <- NULL
  } else{
    sigmaXY <- sigma[j, S]
    sigmaYY <- sigma[S, S]
    coefs <- sigmaXY %*% solve(sigmaYY)
  }
  if (threshold) coefs <- zapsmall(coefs)
  #coefs <- setNames(as.vector(coefs),S)
  beta <- rep(0,d)
  beta[S] <- coefs
  beta <- as(t(beta),"sparseMatrix")
  colnames(beta) <- 1:d
  list(coefs = beta, parents = S, node = j)
}



buildSEM <- function(neighbourhoods, sigma, threshold = TRUE){

    numNodes <- nrow(sigma)
    coefMat <- matrix(0, nrow = numNodes, ncol = numNodes)
    varMat <- matrix(0, nrow = numNodes, ncol = numNodes)

    ### Build coefficient matrix
    for(j in seq_along(neighbourhoods)){
        this.neighourhood <- getParentCoefs(j, neighbourhoods[[j]], sigma)
        coefMat[this.neighourhood$parents, this.neighourhood$node] <- this.neighourhood$coefs
    }

    ### Compute variances
    idMat <- diag(rep(1, numNodes))
    varMat <- t(idMat - coefMat) %*% sigma %*%(idMat - coefMat)
    if(threshold){
        coefMat <- threshold_matrix(coefMat)
        varMat <- threshold_matrix(varMat)
    }

    list(coefs = coefMat, vars = varMat)
}

allProjections <- function(pp){
    nodes <- 1:pp
    nhbds <- all.neighbourhoods(nodes)

    sems <- vector(mode = "list", length = count_all_sem(pp))
    idx <- 1
    for(j1 in nhbds[[1]]){
        for(j2 in nhbds[[2]]){
            for(j3 in nhbds[[3]]){
                for(j4 in nhbds[[4]]){
                    # count_sem <- count_sem + 1
                    neighbourhoodSets <- list(j1, j2, j3, j4)
                    sem <- buildSEM(neighbourhoodSets, Sigma)

                    #print(sem)
                    sems[[idx]] <- list(nhbd = neighbourhoodSets,
                                        coefs = sem$coefs,
                                        vars = sem$vars,
                                        trace = tr(sem$vars),
                                        nedge = count_nonzero(sem$coefs),
                                        betamin = get_smallest_weight(sem$coefs),
                                        acyclic = check_if_dag(sem$coefs),
                                        diagonal = check_if_diag(sem$vars))

                    ### This parameter indicates whether or not an SEM was generated
                    ### by a permutation: If the SEM is a DAG _and_ only one candidate
                    ### set is NULL, then it is generated by a permutation.
                    null_parents <- sum(unlist(lapply(neighbourhoodSets, is.null)))
                    sems[[idx]]$permdag <- sems[[idx]]$acyclic & sems[[idx]]$diagonal & (null_parents == 1)

                    if(sems[[idx]]$acyclic & (null_parents == 0))
                        cat("Crap.")

                    idx <- idx + 1
                }
            }
        }
    }

    sems
}
